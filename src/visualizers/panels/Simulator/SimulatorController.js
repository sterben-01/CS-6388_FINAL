/*globals define, WebGMEGlobal*/

/**
 * Generated by VisualizerGenerator 1.7.0 from webgme on Sun Dec 04 2022 15:52:12 GMT-0600 (Central Standard Time).
 */

let ArcInfo = (client, metaItem, elementId) => {
  console.log("get arcs")
  let arcs = [];
  elementId.forEach((id, i) => {
    let node = client.getNode(id);
    if (client.getNode(node.getMetaTypeId()).getAttribute("name") === metaItem) {
      arcs.push({
        id: id,
        name: node.getAttribute("name"),
        dst: node.getPointerId("dst"),
        src: node.getPointerId("src")
      });
    }
  });
  return arcs;
};

//CITATION------ reference and rearrange from https://github.com/austinjhunt/petrinet-webgme-designstudio/blob/main/petri-net/src/visualizers/panels/SimViz/SimVizControl.js
let check_if_deadlock = (net) => {
  console.log("checking deadlock");
    //return true if there is no enabled transition.
  return Object.keys(net.transitions).every((transId) => {
    getPlaceToTrans(0, transId, net.outputMatrix).every(
      (inPlaceId) => {
        parseInt(net.places[inPlaceId].currentMark) <= 0;
      }
    );
  });
};
 
let getPlacesId = (client, elementId) => {
  console.log("getPlacesID")
  // get the ids of places from the children
  let places = [];
  elementId.forEach((item, i) => {
    if (client.getNode(client.getNode(item).getMetaTypeId()).getAttribute("name") === "Place") {
      places.push(item);
    }
  });
  return places;
};
  
let getTransitionsId = (client, elementId) => {
  console.log("getTransitionsID")
  // from children get transition ID
  let transition = [];
  elementId.forEach((id, i) => {
    if (client.getNode(client.getNode(id).getMetaTypeId()).getAttribute("name") === "Transition") {
      transition.push(id);
    }
  });
  return transition;
};
  
let getOutputItemJson = (placeId, transitionId, arcplace_trans) => {
  let outputJson = {};
  placeId.forEach((pid, i) => {outputJson[pid] = {};
    transitionId.forEach((tid, j) => {
      outputJson[pid][tid] = get_Out_from_PtT(
        pid,
        tid,
        arcplace_trans
      );
    });
  });
  return outputJson;
};
  
let getInputItemJson = (placeId, transitionId, arctrans_place) => {
  let inputJson = {};
  placeId.forEach((pid, i) => {inputJson[pid] = {};
    transitionId.forEach((tid, j) => {
      inputJson[pid][tid] = check_arc_transToplace(
        pid,
        tid,
        arctrans_place
      );
    });
  });
  return inputJson;
};
  
let get_Out_from_PtT = (placeId, transitionId, arcs_PlaceTrans) => {
  // return true if arc from placeId to transitionId else false
  return arcs_PlaceTrans.some((item, index) => {
    return item.src === placeId && item.dst === transitionId;
  });
};
let check_arc_transToplace = (placeId,transitionId,arctrans_place) => {
  // return true if arc from transitionId to placeId
  return arctrans_place.some((arc, index) => {
    if( arc.src === transitionId && arc.dst === placeId){
      return true;
    }
    else{
      return false;
    }
  });
};
let placeHasNoFlow = (item, placeId) => {
  console.log("placehasnoflow");
  //arr has attribute. the second slot is what we want return true if all of the values for the corresponding transitions are false
  return Object.entries(item[placeId]).every((arr) => {
    console.log(arr);
    if(arr[1] == false){
      return true;
    }
    else{
      return false;
    }
  });
};
  
let getStartNodeId = (item) => {
  // the first place will only has output
  for (const placeId in item) {
    if (placeHasNoFlow(item, placeId)) {
      console.log(placeHasNoFlow(item, placeId))
      return placeId;
    }
  }
  for (const placeId in item) {
    return placeId;
  }
};

//CITATION------ reference and rearrange from https://github.com/austinjhunt/petrinet-webgme-designstudio/blob/main/petri-net/src/visualizers/panels/SimViz/SimVizControl.js
let get_Next_Place = (placeId, arcs_P_T, arcs_T_P) => {
  console.log("get_next_place");
  let nextPlaces = [];
  arcs_P_T.filter((arc) => arc.src === placeId).forEach((arc_p2t) => {
    nextPlaces.push(...arcs_T_P.filter((arc_t2p) => arc_t2p.src === arc_p2t.dst).map((arc_t2p) => {
      // do not include already traversed in case of loops
      if (arc_t2p.src === arc_p2t.dst) {
        return arc_t2p.dst;
      }})
    );
  });
  return nextPlaces;
};

let getTransToPlace = (Mode, placeId, param) => {
  
  if(Mode == 0){ //outtrans from place
    console.log("get trans->place mode0")
    return Object.keys(param[placeId]).filter(
      (transId) => param[placeId][transId]
    );
  }
  else if(Mode == 1){ //intrans to place
    console.log("get trans->place mode1")
    return Object.keys(param[placeId]).filter(
      (transId) => param[placeId][transId]
    );
  }
};

let getPlaceToTrans = (Mode, transId, param) => {
  if(Mode == 0){ //Inplace to Trans
    console.log("get inpalce->trans mode0")
    return Object.keys(param).filter(
      (placeId) => param[placeId][transId]
    );
  }
  else if(Mode == 1){//OutPlace from trans
    console.log("get inpalce->trans mode1")
    return Object.keys(param).filter(
      (placeId) => param[placeId][transId]
    );
  }
};
  /*********** END UTILITY FUNCTIONS *************/

define([
    "js/Constants",
    "js/Utils/GMEConcepts",
    "js/NodePropertyNames",
  ], function (CONSTANTS, GMEConcepts, nodePropertyNames) {
    "use strict";
    function SimulatorController(options) {
      this._logger = options.logger.fork("Control");
      console.log("ctor start");
      this._client = options.client;
      // Initialize core collections and variables
      this._widget = options.widget;
      this._widget._client = options.client;
  
      this._currentNodeId = null;
      this._fireableEvents = null;
      this._networkRootLoaded = false;
      this._initWidgetEventHandlers();
      // we need to fix the context of this function as it will be called from the widget directly
      this.setFireableEvents = this.setFireableEvents.bind(this);
      this._logger.debug("ctor finished");
      console.log("ctor finished");
    }
  
    SimulatorController.prototype._initWidgetEventHandlers = function () {
      this._widget.onNodeClick = function (id) {
        // Change the current active object
        WebGMEGlobal.State.registerActiveObject(id);
      };
    };
  
    /* * * * * * * * Visualizer content update callbacks * * * * * * * */
    // One major concept here is with managing the territory. The territory
    // defines the parts of the project that the visualizer is interested in
    // (this allows the browser to then only load those relevant parts).
    SimulatorController.prototype.selectedObjectChanged = function (nodeId) {
      var self = this;
      console.log("------------00000000000000000-----------------")
      self._logger.debug('activeObject nodeId \'' + nodeId + '\'');
      // Remove current territory patterns
      if (self._currentNodeId) {
        self._client.removeUI(self._territoryId);
        self._networkRootLoaded = false;
      }
  
      self._currentNodeId = nodeId;
  
      if (typeof self._currentNodeId === "string") {
        // Put new node's info into territory rules
        self._selfPatterns = {};
        self._selfPatterns[nodeId] = { children: 1 }; // Territory "rule"
        console.log(this);
        self._territoryId = self._client.addUI(self, function (events) {
          console.log(this);
          self._eventCallback(events);
        });
  
        // Update the territory
        self._client.updateTerritory(self._territoryId, self._selfPatterns);
      }
      console.log("------------00000000000000000-----------------")
    };
  
    /* * * * * * * * Node Event Handling * * * * * * * */
    SimulatorController.prototype._eventCallback = function (events) {
      var i = events ? events.length : 0, event;

      console.log('_eventCallback \'' + i + '\' items');
      const self = this;
      events.forEach((event) => {
        if (event.eid && event.eid === self._currentNodeId) {
          if (event.etype == "load" || event.etype == "update") {
            self._networkRootLoaded = true;
          } else {
            this._networkRootLoaded = false;
            this._widget.destroyMachine();
            return;
          }
        }
      });
  
      if (events.length && events[0].etype === "complete" && self._networkRootLoaded) {
        self.InitAll();
      }
      console.log('_eventCallback \'' + events.length + '\' items - DONE');
    };
  
    SimulatorController.prototype._stateActiveObjectChanged = function (model,activeObjectId) {
      if (this._currentNodeId === activeObjectId) {
        // The same node selected as before - do not trigger
      } else {
        this.selectedObjectChanged(activeObjectId);
      }
    };
  
    /* * * * * * * * Machine manipulation functions * * * * * * * */
    //CITATION------ reference and rearrange from https://github.com/austinjhunt/petrinet-webgme-designstudio/blob/main/petri-net/src/visualizers/panels/SimViz/SimVizControl.js
    SimulatorController.prototype.InitAll = function () {
      console.log("initall");
      const meta = {};
      const self = this;
      this._client.getAllMetaNodes().forEach((node) => {
        meta[node.getAttribute("name")] = node.getId(); //we just need the id...
      });
      const elementId = this._client.getNode(this._currentNodeId).getChildrenIds();
      let placeId = getPlacesId(this._client, elementId);
      let transitionId = getTransitionsId(this._client, elementId);
      let ArcTrans_place = ArcInfo(self._client, "ArcTrans_place", elementId);
      let ArcPlace_trans = ArcInfo(self._client, "ArcPlace_trans", elementId);
      let inputJson = getInputItemJson(placeId, transitionId, ArcTrans_place);
      let startingPlaceId = getStartNodeId(inputJson);
      let outputJson = getOutputItemJson(placeId, transitionId, ArcPlace_trans);
      let deadlock = check_if_deadlock;
      let petriNet = {
        deadlockActive: deadlock,
        startingPlace: startingPlaceId,
        places: {},
        transitions: {},
        inputJson: inputJson,
        outputJson: outputJson,
        ArcPlace_trans: ArcPlace_trans,
        ArcTrans_place: ArcTrans_place,
      };
      elementId.forEach((elementId) => {
        const node = self._client.getNode(elementId);
        if (node.isTypeOf(meta["Place"])) {
          petriNet.places[elementId] = {
            id: elementId,
            name: node.getAttribute("name"),
            currentMark: parseInt(node.getAttribute("currentMark")),
            nextPlaceIds: get_Next_Place(
              elementId,
              ArcPlace_trans,
              ArcTrans_place
            ),
            outTransitions: getTransToPlace(0, elementId, outputJson),
            inTransitions: getTransToPlace(1, elementId, inputJson),
            outArcs: ArcPlace_trans.filter((arc) => arc.src === elementId),
            position: node.getRegistry("position"),
          };
        } else if (node.isTypeOf(meta["Transition"])) {
          petriNet.transitions[elementId] = {
            id: elementId,
            name: node.getAttribute("name"),
            outPlaces: getPlaceToTrans(1, elementId, inputJson),
            inPlaces: getPlaceToTrans(0, elementId, outputJson),
            outArcs:ArcTrans_place.filter((arc) => arc.src === elementId),
            position: node.getRegistry("position"),
          };
        }
      });
      petriNet.setFireableEvents = this.setFireableEvents;
      self._widget.initMachine(petriNet);
    };



    //CITATION------ reference and rearrange from https://github.com/austinjhunt/petrinet-webgme-designstudio/blob/main/petri-net/src/visualizers/panels/SimViz/SimVizControl.js
    SimulatorController.prototype.setFireableEvents = function (enabledTransitions) {
      this._fireableEvents = enabledTransitions;
      if (enabledTransitions && enabledTransitions.length >= 1) {
        // fill dropdown button with options. only including enabled transitions
        this.$btnEventSelector.clear();
        enabledTransitions.forEach((transition) => {
          this.$btnEventSelector.addButton({
            text: `Start enabled transition ${transition.name}`,
            title: `Start enabled transition ${transition.name}`,
            data: { event: transition },
            clickFn: (data) => {
              this._widget.fireEvent(data.event);
            },
          });
        });
      } else if (enabledTransitions && enabledTransitions.length === 0) {
        this._fireableEvents = null;
      }
      this._displayToolbarItems();
    };
  
    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    SimulatorController.prototype.destroy = function () {
      this._detachClientEventListeners();
      this._removeToolbarItems();
    };
  
    SimulatorController.prototype._attachClientEventListeners = function () {
      this._detachClientEventListeners();
      WebGMEGlobal.State.on("change:" + CONSTANTS.STATE_ACTIVE_OBJECT,this._stateActiveObjectChanged,this);
    };
  
    SimulatorController.prototype._detachClientEventListeners = function () {
      WebGMEGlobal.State.off("change:" + CONSTANTS.STATE_ACTIVE_OBJECT,this._stateActiveObjectChanged);
    };
  
    SimulatorController.prototype.onActivate = function () {
      this._attachClientEventListeners();
      this._displayToolbarItems();
  
      if (typeof this._currentNodeId === "string") {
        WebGMEGlobal.State.registerActiveObject(this._currentNodeId, {suppressVisualizerFromNode: true,});
      }
    };
  
    SimulatorController.prototype.onDeactivate = function () {
      this._detachClientEventListeners();
      this._hideToolbarItems();
    };
  
    /* * * * * * * * * * Updating the toolbar * * * * * * * * * */
    SimulatorController.prototype._displayToolbarItems = function () {
      if (this._toolbarInitialized === true) {
        if (this._fireableEvents === null || this._fireableEvents.length == 0) {
          this.$btnEventSelector.hide();
          this.$deadlockLabel.show();
          this.$btnResetMachine.show();
        } else {
          this.$btnEventSelector.show();
          this.$btnResetMachine.show();
          this.$deadlockLabel.hide();
        }
      } else {
        this._initializeToolbar();
      }
    };
  
    SimulatorController.prototype._hideToolbarItems = function () {
      if (this._toolbarInitialized === true) {
        for (var i = this._toolbarItems.length; i--; ) {
          this._toolbarItems[i].hide();
        }
      }
    };
  
    SimulatorController.prototype._removeToolbarItems = function () {
      if (this._toolbarInitialized === true) {
        for (var i = this._toolbarItems.length; i--; ) {
          this._toolbarItems[i].destroy();
        }
      }
    };
  
    SimulatorController.prototype._initializeToolbar = function () {
      var self = this,
            toolBar = WebGMEGlobal.Toolbar;

      this._toolbarItems = [];

      this._toolbarItems.push(toolBar.addSeparator());
      /************** Go to hierarchical parent button ****************/
      //CITATION------ reference and rearrange from https://github.com/austinjhunt/petrinet-webgme-designstudio/blob/main/petri-net/src/visualizers/panels/SimViz/SimVizControl.js
      self.$btnModelHierarchyUp = toolBar.addButton({
        title: 'Go to parent',
        icon: "glyphicon glyphicon-question-sign",
        clickFn: function (/*data*/) {
          WebGMEGlobal.State.registerActiveObject(self._currentNodeParentId);

        },
      });
      self._toolbarItems.push(self.$btnModelHierarchyUp);
  
      self.$btnResetMachine = toolBar.addButton({
        title: "Reset Simulator",
        text: "Reset Simulator  ",
        icon: "glyphicon glyphicon-fast-backward",
        clickFn: function (/*data*/) {
          self._widget.resetMachine();
        },
      });
      self._toolbarItems.push(self.$btnResetMachine);
  
      // when there are multiple enabled transitions to choose
      // from we offer a selector
      self.$btnEventSelector = toolBar.addDropDownButton({
        text: "Start a enabled transition  ",
        title: "Start a enabled transition",
        icon: "glyphicon glyphicon-play",
      });
      self._toolbarItems.push(self.$btnEventSelector);
      self.$btnEventSelector.hide();
      self.$deadlockLabel = toolBar.addLabel();
      self.$deadlockLabel.text("DEADLOCK HAPPENED ----> NO ENABLED TRANSITIONS");
      self._toolbarItems.push(self.$deadlockLabel);
      self.$deadlockLabel.hide();
      /************** Dropdown for event progression *******************/
      self._toolbarInitialized = true;
    };
  
    return SimulatorController;
  });